// 2) Метод - это программа, которая выполняет рутинный код.
//Заполнить 50 массивов, если есть метод: он вызывается 50 раз.
//Если циклом for, то он = 50 циклам.
//Получается, что метод гораздо практичнее. Не "засоряя" код.
//Допустим в цикле 400 строк * 50 раз = 20000 строк.
//Лучше 50 раз вызвать метод, который состоит из 400 строк.

//тип возвращаемого значения (int; double; string) => Имя_Метода (PascaleCase)

//tipe NameMethod (params)
//int Calcalute (int a, int b)

int A = Convert.ToInt32(Console.ReadLine());
int GetsSumNumbers(int number) //number-это локальная переменная; она живёт только в пределах функции.
//Мы можем через GetsSumNumbers(А), тогда значение int A, введённого с терминала числа, будет в этом методе.
{
    //while  Давайте реализуем наш метод через этот цикл.
    int sum = 0; //Создали переменную "sum", где будет складироваться наш результат.
    int start = 1; // Начало нашего цикла.
    while(start <= number)
    {
        sum += start; //sum = sum + start
        start++; //start = start + 1
    }
    return sum; //CW - печать, return - возврат. Между собой они никак не =.
                //Если 1 return сработал из 50, то остальные False. То есть функция уже отработала.
                //Смысл "return", такое же как у цикла "else if"(иначе, если).
                //По факту оптимизирует наш код. Вызов return = функция закончилась и мы переносимся к месту вызова
    //while(start <= number)
    //{
        //sum += start; //sum = sum + start
        //start++; //start = start + 1       Если буде такое продолжение, то данная часть кода FALSE
    //}
    //return sum;     
}
Console.WriteLine($"Сумма чисел от 1 до {A} = {GetsSumNumbers(A)} ");
//Мы хотим поменять переменные в GetsSumNumbers с number на А.
//Это нам нужно для того, чтобы увидеть искомый результат функции. Иначе FALSE.
